+++
# `title` is how your post will be listed and what will appear at the top of the post
title= "Valkey 8.1: Continuing to Deliver Enhanced Performance and Reliability"
# `date` is when your post will be published.
# For the most part, you can leave this as the day you _started_ the post.
# The maintainers will update this value before publishing
# The time is generally irrelvant in how Valkey published, so '01:01:01' is a good placeholder
date= 2025-11-03 01:01:01
# 'description' is what is shown as a snippet/summary in various contexts.
# You can make this the first few lines of the post or (better) a hook for readers.
# Aim for 2 short sentences.
description= "The first release candidate of Valkey 8.1 is now available! Come learn about the exciting improvements in performance, reliability, and observability that are available in this new version."
# 'authors' are the folks who wrote or contributed to the post.
# Each author corresponds to a biography file (more info later in this document)
authors= [ "rdias", "mvisser" ]
+++


The Valkey community is proud to unveil the first release candidate of Valkey 8.1,
a minor update designed to further enhance performance, reliability, and observability 
over Valkey 8.0 for all Valkey installations. 
In this blog, we'll dive a bit deeper into each of these areas 
and talk about the exciting features built for this release.

## Performance

There are a lot of changes in 8.1 that improve Valkey's performance either by decreasing the latency of some operations, increasing the througput of some operations, or reducing the memory footprint of the overall system.

One of the main changes responsible for several performance improvements is the new hashtable implementation that is used as the main key-value store in Valkey and also used in the Hash, Set, and Sorted Set datatypes implementation.

### The New Hashtable

Valkey is a distributed key-value and therefore is no suprise that a hashtable data structure performs an important role in the way Valkey works.

Almost all commands go through the main key-value store where the several datatypes values are stored, and therefore the hashtable implementation is present in the critical path of most workloads.

The new hashtable implementation is a complete rewrite of the previous hashtable implementation, which reduces the￼memory usage by roughly 20 bytes per key-value pair and improves the latency and ￼CPU usage by rougly 10% for instances without I/O threading.

The previous hashtable implementation, called `dict`, had the traditional design of an array of buckets where each bucket is a collision list. Each collision list element is called a `dictEntry` and holds a single key-value pair. The `dictEntry` structure stores three pointers, one for the key, one for the value, and one for the next `dictEntry` in the collision list. In terms of memory consumption, in a 64bit architecture, each `dictEntry` takes 24 bytes of memory.

```
    +-----------+         +-------+
    | dictEntry |    .--->| "FOO" |
    +-----------+   /     +-------+
    |    key  -----'
    |           |         +-------------------+
    |   value ----------->| serverObject      |
    |           |         +-------------------+
    |   next    |         | type, encoding,   |
    +-----|-----+         | ref-counter, etc. |
          |               | "BAR" (embedded)  |
          v               +-------------------+
    +-----------+
    | dictEntry |
    +-----------+
    |    key    |
    |   value   |
    |   next    |
    +-----|-----+
          |
          v
         ...
```

Regarding memory accesses, the above design requires at least 4 memory accesses to get the value in the case that the key is stored in the first `dictEntry` of the collision list. This might have a significant impact in cache locality when traversing the collision list search for the right key.

The new hashtable implementation improves on the memory footprint required and on the cache locality by taking a different approach on the design of each bucket. Each bucket has a fixed size of 64 bytes (in a 64bit architecture), which usually corresponds to the size of a single cache line. The bucket structure stores 7 pointers, 8 bytes each, plus 8 bytes used for metadata. The 7 pointers are used to store up to 7 entries. Keys that map to the same bucket are all stored in the same bucket. If more than 7 keys map to the same bucket, a new bucket is linked to the previous one using the last of the 7 pointers. Each entry pointer, points to an object that may embed the key and the value.

The 8 bytes of metadata is composed of 1 bit that indicated if there's child bucket linked, 7 bits that are used to indicate the presence of entries, and 7 bytes used as a secondary hash for each entry stored in the bucket.

```
       0          8       16      24      32      40      48      56      64  bytes
       +------------------------------------------------------------------+
       | Metadata | Entry | Entry | Entry | Entry | Entry | Entry | Entry |
       +------------------------------------------------------------------+
      /            ` - - . _ _
     /                         `- - . _ _
    /                                     ` - . _
   +----------------------------------------------+
   | c ppppppp hash hash hash hash hash hash hash |
   +----------------------------------------------+
    |    |       |
    |    |      One byte of hash for each entry position in the bucket.
    |    |
    |   Presence bits. One bit for each entry position, indicating if an
    |   entry present or not.
    |
   Chained? One bit. If set, the last entry is a child bucket pointer.
```

The secondary hashes are used for quickly eliminating hash collisions when looking up a key. In this way, we can avoid comparing the key for a mismatching key, except once in 256.

This new design reduces by one the number of memory accesses required to lookup an entry when there are no collisions, but it reduces a lot more memory accesses to lookup an entry when there are key mapping collisions because each bucket can store 7 entries.

It also reduces the memory footprint by a lot when there are collisions. With 3 keys mapping to the same bucket, the new design is already using less 8 bytes than the old design, which requires 72 bytes of memory (3 `dictEntry` objects). In the new design, the 64 byte bucket can store up to 7 entries, while the old design would require 168 bytes.


### Other Performance Improvements



## Reliability

## Extensability

Valkey is already well known by its extensability features. The sophisticated module sytem allows to extend the core system with new features developed as external modules.

In Valkey 8.1 the module system API was extended with the support for developing new scripting engines as external modules.

This new API opens the door for the development of new language and runtime alternatives to the Lua base scripts supported by the Valkey core when using `EVAL` and `FCALL` commands.

In the future we expect the emergence of new scripting engines. A good candidate is a scripting engine based on WASM, allowing `EVAL` scripts to be written in other languages than Lua and to be executed in more secure sandbox environment.

There are also benefits for existing Lua scripts, since new Lua runtimes can be easily plugged in that provide better security properties and/or better performace.

Developers that intend to build new scripting engines for Valkey should check the [Module API](https://valkey.io/topics/modules-api-ref/) documentation.


## Replication


## Observability


## Additional Highlights

### Conditional updates

This new functionality allows Valkey users to perform conditional updates using the SET command if the given comparison-value matches the key’s current value. This is a not only a quality-of-life improvement for developers as they no longer need to add this condition to their application code, it also saves a roundtrip to first get a value and then compare it before a SET. When using the optional GET as part of the SET IFEQ, the existing value is returned regardless whether it matches the comparison-value.

Syntax:

    SET key value [ NX | XX | IFEQ comparison-value ] [ GET ] [ EX seconds | PX milliseconds | EXAT unix-time-seconds | PXAT unix-time-milliseconds | KEEPTTL ]

## Conclusion


We look forward to hearing what you achieve with Valkey 8.1!
